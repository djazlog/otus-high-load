# Отложенная материализация ленты

## Описание

Система отложенной материализации ленты реализована для оптимизации производительности при формировании лент пользователей. Вместо синхронного обновления лент при создании постов, система использует очередь сообщений для асинхронной обработки.

## Архитектура

### Компоненты

1. **RabbitMQ** - брокер сообщений для очередей
2. **Feed Service** - сервис отложенной материализации ленты
3. **Feed Repository** - репозиторий для работы с материализованными лентами
4. **Queue Client** - клиент для работы с RabbitMQ
5. **Feed Worker** - воркер для обработки задач материализации

### Схема работы

1. **Создание поста**: При создании поста система планирует обновление лент для всех друзей автора
2. **Публикация в очередь**: Задачи обновления ленты публикуются в RabbitMQ с routing keys для целевых пользователей
3. **Обработка воркером**: Воркер потребляет задачи из очереди и обновляет материализованные ленты
4. **WebSocket уведомления**: Параллельно отправляются уведомления через WebSocket для реального времени

## Конфигурация

### Переменные окружения

```bash
# RabbitMQ
RABBITMQ_HOST=localhost
RABBITMQ_PORT=5672
RABBITMQ_USERNAME=guest
RABBITMQ_PASSWORD=guest
RABBITMQ_VHOST=/
```

### Структура очередей

- **Exchange**: `feed.events` (topic)
- **Queue**: `feed.materialization`
- **Routing Key**: `feed.event.{user_id}`

## Использование

### Запуск системы

```bash
# Запуск всех сервисов
make up

# Запуск основного сервера
make run

# Запуск воркера материализации ленты (отдельно)
make feed-worker
```

### Мониторинг

- **RabbitMQ Management**: http://localhost:15672 (guest/guest)
- **Prometheus**: http://localhost:9090
- **Grafana**: http://localhost:3000 (admin/pass)

## База данных

### Таблицы

#### materialized_feeds
```sql
CREATE TABLE materialized_feeds (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL,
    post_id UUID NOT NULL,
    author_id UUID NOT NULL,
    post_text TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE,
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(user_id, post_id)
);
```

#### feed_jobs
```sql
CREATE TABLE feed_jobs (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL,
    post_id UUID NOT NULL,
    status VARCHAR(20) NOT NULL,
    priority INTEGER NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE,
    updated_at TIMESTAMP WITH TIME ZONE,
    error TEXT
);
```

### Индексы

- `idx_materialized_feeds_user_id` - для быстрого поиска ленты пользователя
- `idx_materialized_feeds_created_at` - для сортировки по времени
- `idx_feed_jobs_status` - для поиска заданий по статусу
- `idx_feed_jobs_priority` - для приоритизации обработки

## API

### Получение материализованной ленты

```go
// Получение ленты пользователя
feeds, err := feedService.GetMaterializedFeed(ctx, userID, offset, limit)
```

### Планирование обновления ленты

```go
// Планирование обновления ленты для друзей автора
err := feedService.ScheduleFeedUpdate(ctx, postID, authorID, postText)
```

## Преимущества

1. **Производительность**: Создание постов не блокируется обновлением лент
2. **Масштабируемость**: Возможность горизонтального масштабирования воркеров
3. **Надежность**: Очередь обеспечивает надежную доставку сообщений
4. **Целевая доставка**: Routing keys обеспечивают отправку только целевым пользователям
5. **Мониторинг**: Отслеживание статуса обработки заданий

## Ограничения

1. **Задержка**: Ленты обновляются с небольшой задержкой
2. **Сложность**: Дополнительная сложность в архитектуре
3. **Зависимость от RabbitMQ**: Требуется дополнительная инфраструктура

## Мониторинг и метрики

### Метрики для отслеживания

- Количество задач в очереди
- Время обработки задач
- Количество ошибок обработки
- Размер материализованных лент
- Производительность воркеров

### Алерты

- Высокое количество задач в очереди
- Длительное время обработки
- Высокий процент ошибок
- Недоступность RabbitMQ

## Планы развития

1. **Приоритизация**: Реализация приоритетной обработки для VIP пользователей
2. **Batch обработка**: Группировка задач для оптимизации
3. **Dead Letter Queue**: Обработка неудачных задач
4. **Retry механизм**: Автоматические повторы при ошибках
5. **Кэширование**: Кэширование часто запрашиваемых лент
